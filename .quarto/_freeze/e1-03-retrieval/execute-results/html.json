{
  "hash": "3a3d45d9840b54b21cf540f4755dbe4b",
  "result": {
    "markdown": "## e1 Retrieval Rate\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(ez)\nlibrary(gt)\nlibrary(rsvg)\nlibrary(svglite)\n```\n:::\n\n\nRetrieval Rate is \"How many trees did they visit to get this fruit?\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(contrasts=c(\"contr.sum\",\"contr.poly\"))\noptions(dplyr.summarise.inform=F)\nknitr::opts_chunk$set(message = FALSE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(ez)\nlibrary(gt)\npd <- position_dodge(0.1)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ne1 <- readRDS(\"001-00-e1-data.RDS\")\n\n# remove things from the raw data to make it suitable \n# for this particular analysis\n\n# remove samples that did not look at a tree\ne1 <- e1 %>% \n  filter(fl>0)\n\n# remove the second (and any subsequent) *consecutive* duplicates\ne1 <- e1 %>% \n  filter(is.na(tl != lag(tl)) | tl != lag(tl))\n\n# remove trials where they failed to get 10 fruit\ne1 <- e1 %>% \n  group_by(pp, te) %>% \n  mutate(max_fr = max(fr)) %>% \n  ungroup() %>% \n  filter(max_fr==10) %>% \n  select(-c(max_fr))\n```\n:::\n\n\nAnnotate: \"How many trees did they visit to get this fruit?\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne1.retrieval <- e1\ne1.retrieval$n_trees_per_fruit = NA\nj = 0\nfor (k in seq_along(e1.retrieval$ix)) {\n j = j + 1\n if (e1.retrieval[k, 'fl']==2) {\n   e1.retrieval[k, 'n_trees_per_fruit'] = j\n   j = 0\n }\n}\n```\n:::\n\n\nYou don't want to retain zero counts because\nthere is no such thing as 0 for \"How many trees did they visit to get this fruit?\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne1.retrieval <- e1.retrieval %>%  \n  filter(n_trees_per_fruit != 0)\n```\n:::\n\n\nThe data are valid row-per-sample here.\n\nWe want to collapse to the level of the fruit-seeking event.\n\nBy definition, fr==0 is NA for n_trees_per_fruit -- they haven't got a fruit yet, so they can't have visited any trees to get to no fruit.\n\nThere is no such thing as 0 for \"How many trees did they visit to get this fruit?\" so we don't do anything about having a sparse matrix.\n\nThe minimum number of trees looked at to get a fruit is 1: the look that scored the fruit.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne1.retrieval_per_fruit <- e1.retrieval %>% \n  group_by(across(c(ex,pp,rr,st,tb,fr))) %>% \n  summarise(retrieval_per_fruit = sum(na.rm=T,n_trees_per_fruit))\n```\n:::\n\n\nCollapse over trials to yield average per-fruit n trees\n\n\n::: {.cell}\n\n```{.r .cell-code}\ne1.mean_retrieval_per_fruit <- e1.retrieval_per_fruit %>% \n  group_by(across(c(ex,pp,rr, fr))) %>% \n  summarise(mean_retrieval_per_fruit = mean(retrieval_per_fruit))\n```\n:::\n\n\nMake plot data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsaveRDS(e1.mean_retrieval_per_fruit,\"e1_retrieval_plot_data.rds\")\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}